You are working inside an existing project repository.

You must go straight to implementation. Do not enter planning mode. Do not describe what you are going to do. Do not suggest committing changes. Do not modify `main` or `cli` under any circumstance.

---

## Absolute Rules

1. Create a new top-level directory called `frontend` alongside `main` and `cli`.
2. Do NOT modify anything inside `main` or `cli`.
3. Do NOT suggest modifying `main` or `cli`.
4. The frontend must NEVER use dummy data. Do not ask to use dummy data. Do not simulate data.
5. The UI must only work with real configurations and real pipeline execution.
6. The frontend must behave exactly like the CLI, but with a graphical interface.
7. Before any other implementation, create a file at the root called `claude.md` with the following rule:

   - For every frontend change: do not change the code in `main` or `cli`.
   - Never suggest changing `main` or `cli`.
   - Never use dummy data in the UI.
   - Only use real raw data and real configs.

This file must be treated as a hard constraint for all future prompts.

---

## Frontend Requirements

Create a Shiny R application inside the new `frontend` directory.

There is an existing `demo` directory containing JavaScript UI code. Convert its structure and design into a Shiny application. The visual structure and flow should be preserved, but rewritten fully in Shiny (R).

To gain further visual and structural context for what the UI should look like, refer to the screenshots located at:

`/Users/izzydavidson/Desktop/STaBioM/stabiom_photos`

These screenshots define the intended layout, styling, flow, and visual hierarchy. Match them as closely as possible using Shiny.

The Shiny app is strictly a frontend layer. Its only responsibilities:

- Generate pipeline configuration files exactly the same way the CLI does.
- Trigger the pipeline execution the same way the CLI does.
- Capture and display the CLI log output in real time inside the UI.
- Do not change how logging works in `main` or `cli`. The CLI already logs to terminal. Simply stream and render that output in a terminal-style log panel.

---

## Functional Pages

### 1. Setup Wizard
- Read the setup wizard README in root.
- Trigger automatically for first-time users.
- Allow users to:
  - Select required tools
  - Download Docker (if needed)
  - Download reference databases
  - Automatically configure file paths
- Allow users to revisit the wizard anytime.
- Integrate with existing wizard and postprocessing scripts located on Desktop.
- No dummy state simulation â€” reflect real installation state.

---

### 2. Dashboard (Landing Page)
- Navigation cards for:
  - Short Read
  - Long Read
  - Compare
  - Run Progress
- Quick-access cards
- Clean, modern gray/blue design
- Responsive layout (desktop + mobile)

---

### 3. Short Read
Configuration interface for:
- sr_amp
- sr_meta

Must:
- Generate configs identical to CLI
- Include conditional fields (e.g. Valencia only for vaginal samples)
- Show real-time parameter summary panel
- Validate inputs with indicators
- Use sticky sidebar panels

---

### 4. Long Read
Configuration interface for:
- lr_amp
- lr_meta

Same behavior as Short Read but for long-read pipelines.

---

### 5. Compare
Interface to compare pipeline runs.
Use standardized outputs generated by the pipeline.

---

### 6. Run Progress
- Real-time terminal-style log display
- Stream CLI output directly
- Color-coded log messages
- No simulated logs
- No mock progress

---

## UI Requirements

- Clean gray/blue theme
- Fully responsive
- Sticky sidebar panels
- Conditional field display
- Input validation indicators
- Real-time parameter summary
- Navigation between pages
- Terminal-style log display
- Color-coded logs

The application must automatically open a browser tab when launched.

---

## Pipeline Context

Read the root `README.md` to understand:

- Short-read amplicon (QIIME2/DADA2)
- Long-read amplicon (Emu/Kraken2)
- Metagenomics (Kraken2/Bracken)
- Valencia CST classification
- Standardized outputs (taxonomy tables, diversity metrics, visualizations)
- Docker-based containerized execution
- Zero dependency binary (Python bundled)

The Shiny app must fully align with how the CLI executes these pipelines.

---

## Critical Architectural Rule

The frontend is only a UI wrapper.

It must:
- Create configs exactly like CLI.
- Execute pipelines exactly like CLI.
- Display CLI logs exactly as produced.

It must never:
- Reimplement pipeline logic.
- Modify main or cli.
- Change logging behavior.
- Introduce dummy data.
- Simulate execution.

Implement now.

